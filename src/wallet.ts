import { Keypair } from "@solana/web3.js";
import bs58 from "bs58";
import fs from "node:fs";
import path from "node:path";
import os from "node:os";

export type WalletData = {
  // Local keypair (generated by OpenClaw)
  secretKey: string; // base58 encoded secret key
  address: string; // base58 public key (signer address)
  createdAt: string;

  // From web app (after user completes delegation)
  smartWalletAddress?: string; // The Crossmint smart wallet address
  apiKey?: string; // Client-side API key from Crossmint
  configuredAt?: string; // When the user completed setup
};

export type WalletStore = {
  wallets: Record<string, WalletData>;
};

function getWalletsDir(): string {
  // Allow override for testing
  const override = process.env.CROSSMINT_WALLETS_DIR;
  if (override) {
    return override;
  }
  return path.join(os.homedir(), ".openclaw", "crossmint-wallets");
}

function ensureWalletsDir(): void {
  const dir = getWalletsDir();
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true, mode: 0o700 });
  }
}

function getStorePath(): string {
  return path.join(getWalletsDir(), "wallets.json");
}

function loadStore(): WalletStore {
  ensureWalletsDir();
  const storePath = getStorePath();
  if (!fs.existsSync(storePath)) {
    return { wallets: {} };
  }
  try {
    const data = fs.readFileSync(storePath, "utf-8");
    return JSON.parse(data) as WalletStore;
  } catch {
    return { wallets: {} };
  }
}

function saveStore(store: WalletStore): void {
  ensureWalletsDir();
  const storePath = getStorePath();
  fs.writeFileSync(storePath, JSON.stringify(store, null, 2), {
    encoding: "utf-8",
    mode: 0o600, // Secure file permissions
  });
}

export function getOrCreateWallet(agentId: string): WalletData {
  const store = loadStore();

  if (store.wallets[agentId]) {
    return store.wallets[agentId];
  }

  // Generate new Solana keypair
  const keypair = Keypair.generate();
  const walletData: WalletData = {
    secretKey: bs58.encode(keypair.secretKey),
    address: keypair.publicKey.toBase58(),
    createdAt: new Date().toISOString(),
  };

  store.wallets[agentId] = walletData;
  saveStore(store);

  return walletData;
}

export function getWallet(agentId: string): WalletData | null {
  const store = loadStore();
  return store.wallets[agentId] ?? null;
}

export function isWalletConfigured(agentId: string): boolean {
  const wallet = getWallet(agentId);
  return !!(wallet?.smartWalletAddress && wallet?.apiKey);
}

export function configureWallet(
  agentId: string,
  smartWalletAddress: string,
  apiKey: string,
): WalletData {
  const store = loadStore();
  const existing = store.wallets[agentId];

  if (!existing) {
    throw new Error(`No wallet found for agent "${agentId}". Generate keypair first.`);
  }

  store.wallets[agentId] = {
    ...existing,
    smartWalletAddress,
    apiKey,
    configuredAt: new Date().toISOString(),
  };

  saveStore(store);
  return store.wallets[agentId];
}

export function listWallets(): Record<string, WalletData> {
  const store = loadStore();
  return store.wallets;
}

export function deleteWallet(agentId: string): boolean {
  const store = loadStore();
  if (!store.wallets[agentId]) {
    return false;
  }
  delete store.wallets[agentId];
  saveStore(store);
  return true;
}

export function getKeypair(agentId: string): Keypair | null {
  const walletData = getWallet(agentId);
  if (!walletData) {
    return null;
  }

  const secretKey = bs58.decode(walletData.secretKey);
  return Keypair.fromSecretKey(secretKey);
}

export async function signMessage(agentId: string, message: Uint8Array): Promise<Uint8Array> {
  const keypair = getKeypair(agentId);
  if (!keypair) {
    throw new Error(`No wallet found for agent: ${agentId}`);
  }

  // Solana uses ed25519 signing via nacl
  const nacl = (await import("tweetnacl")).default;
  return nacl.sign.detached(message, keypair.secretKey);
}
